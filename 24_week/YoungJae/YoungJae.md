# BOJ_1234 토끼의 이동

## 문제 주소
https://www.acmicpc.net/problem/3101

- 문제
주택난을 해결하기 위해서 직선 도로 하나를 따라 여러 아파트 단지들을 지었다. 또, 이 아파트 단지 주민을 위해 도로 위 한 지점에 학교 하나를 신설하였다. 아파트 단지들이 서로 멀리 떨어져 있기 때문에 반드시 통학버스를 이용해서만 다닐 수 있고, 통학버스는 한 대이다.

각각의 아파트 단지와 학교의 위치는 도로 위의 좌표로 주어지며, 또 각 아파트 단지마다 여기에 사는 학생들의 수도 주어진다. 통학버스는 아침에 학교를 출발하여 각 아파트 단지에 있는 학생들을 태우고 학교로 다시 돌아온다. 이 통학버스는 정원을 초과하여 학생을 태울 수 없고, 모든 학생을 등교시킬 때까지 이 과정을 반복한다. 

위 규칙을 따라서 모든 학생들을 학교에 등교시키는 예를 보자. 아파트 단지 A, B, C가 각각 좌표 0, 2, 5에 있고 이 단지에 사는 학생은 각각 1, 2, 1명이라고 하자. 두 지점 간의 거리는 두 지점 좌표의 차이로 정의된다. 최대 4명이 탈 수 있는 통학버스가 좌표 4에 있는 학교에서 출발해서 모든 학생들을 등교시킬 때, 버스는 먼저 단지 B를 들러 2명을 태우고, 단지 A를 들러서 1명을 태우고 다시 학교로 돌아온다면 이동 거리는 2 + 2 + 4 = 8이다. 다시 학교에서 아파트 단지 C로 이동하여 1명을 태우고 돌아오면 이동 거리는 1 + 1 = 2가 되고, 총 이동거리는 8 + 2 = 10이 된다. 

학교의 위치, 각각의 아파트 단지의 위치와 학생 수, 통학버스의 정원이 주어졌을 때, 모든 학생을 등교시키는데 필요한 통학버스의 총 이동 거리의 최솟값을 계산하는 프로그램을 작성하시오. 

- 입력
첫째 줄에는 세 개의 양의 정수 N, K, S가 빈칸을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 아파트 단지의 수이며 2 ≤ N ≤ 30,000이다. 두 번째 정수 K는 1 ≤ K ≤ 2,000이며, 통학버스의 정원이다. 세 번째 정수 S는 학교의 위치를 나타낸다. 둘째 줄부터 N+1번째 줄에는 각 아파트 단지의 위치를 나타내는 정수와 이 단지에 사는 학생 수를 나타내는 정수가 빈칸을 사이에 두고 주어진다. 학교와 아파트 단지의 좌표는 0 이상 100,000 이하이며, 이 좌표들은 모두 서로 다르다. 각 아파트 단지의 학생 수는 1 이상 2,000 이하이다. 

- 출력
첫째 줄에 주어진 입력에서 통학버스의 최소 이동 거리를 출력한다. 최소 이동 거리가 1,000,000,000을 초과하는 경우는 없다. 

## 문제 접근 방법
그리디한 접근으로 푸는 문제였다.
먼 곳부터 시작하여 인원을 태워 정원을 채우면 학교로 간 뒤 다시 가장 먼 지역으로 가는 방식으로 반복하여 풀었다.
다만 학교 좌측/우측을 왔다갔다하면 최소거리가 되지 않기 때문에 좌측은 좌측, 우측은 우측으로 나눠서 계산 후 합한다.

### 코드
```python
# 버스 이동 계산
def bus(ls):
    # 버스 이동 거리 rst, 현재 버스 탑승 인원 t
    rst = 0; t = 0
    for l, m in ls:
        while 1:
            # 버스에 인원이 없으면 학교를 갔다 온거기 때문에 새 곳으로 이동
            # 왔다갔다니 * 2
            if not t: rst += l * 2
            # 현재 지역 인원이 다 타도 정원초과가 안나면 태우고 다음 지역 이동
            if k >= m + t: t += m; break
            # 정원초과 나면 전부 태우고 남은 인원만 m에 남겨두고
            # t는 학교를 갔다올거기 때문에 0으로 처리
            m += t - k; t = 0
    return rst

n, k, s = map(int, input().split())
rp = {}; rm = {}
for _ in range(n):
    i, j = map(int, input().split())
    # 학교보다 멀리 있으면 rp에 가까이 있으면 rm에 추가
    if i > s: rp[i - s] = j
    else: rm[s - i] = j
# 각각을 정렬
rp = sorted(rp.items(), reverse=True)
rm = sorted(rm.items(), reverse=True)
# +지역 갔다가 m지역 갔다가 학교 가는 일은 최소거리가 아니기 때문에
# 각각의 경우를 나눠서 합산
print(bus(rm) + bus(rp))
```